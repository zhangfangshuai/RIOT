var gutil, through, ref$, compile, parsers;
gutil = require('gulp-util');
through = require('through2');
ref$ = require('riot'), compile = ref$.compile, parsers = ref$.parsers;
module.exports = function(opts){
  var transform;
  opts == null && (opts = {});
  transform = function(file, encoding, callback){
    var compiledCode, err, splitedPath;
    switch (false) {
    case !file.isNull():
      return callback(null, file);
    case !file.isStream():
      return callback(new gutil.PluginError('gulp-riot', 'Stream not supported'));
    default:
      if (opts.parsers != null) {
        Object.keys(opts.parsers).forEach(function(x){
          return Object.keys(opts.parsers[x]).forEach(function(y){
            return parsers[x][y] = opts.parsers[x][y];
          });
        });
        delete opts.parsers;
      }
      try {
        compiledCode = compile(file.contents.toString(), opts, file.path);
      } catch (e$) {
        err = e$;
        return callback(new gutil.PluginError('gulp-riot', file.path + ": Compiler Error: " + err));
      }
      if (opts.modular) {
        compiledCode = "(function(tagger) {\n  if (typeof define === 'function' && define.amd) {\n    define(['riot'], function(riot) { tagger(riot); });\n  } else if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    tagger(require('riot'));\n  } else {\n    tagger(window.riot);\n  }\n})(function(riot) {\n" + compiledCode + "\n\n});";
      }
      file.contents = new Buffer(compiledCode);
      splitedPath = file.path.split('.');
      splitedPath[splitedPath.length - 1] = 'js';
      file.path = splitedPath.join('.');
      return callback(null, file);
    }
  };
  return through.obj(transform);
};